#!/bin/python3
import sys
import math
import subprocess
from table import *

class Clingo:
    @staticmethod
    def resolve(text, args=[], max_solutions=0):

        execLine = ['clingo', '--verbose=0', '{0}'.format(max_solutions)]
        execLine.extend(args)

        # Execute clingo with text string as input
        cp = subprocess.run(            
            execLine, 
            input=text.encode('utf-8'),
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )

        stderr = str(cp.stderr, encoding='utf-8')
        stdout = str(cp.stdout, encoding='utf-8')

        # Raise a exception if stderr is not empty
        if len(stderr) != 0:
            raise Exception('{}\n{}'.format(text, stderr))

        # Parse the solutions        
        solutions = stdout.split('\n')
        solutions.remove('')
        return solutions[:-1], solutions[-1]
    
def pass_rule_1(n, t):
    nh = n // 2
    passed = True
    for i in range(0, n):
        # Rows
        count = len(list(filter(lambda x: x == '0', t.get_row(i))))
        if count != nh:
            #print('Zero count at row {} is: {} != {}'.format(i + 1, count, nh))
            passed = False

        count = len(list(filter(lambda x: x == '0', t.get_col(i))))
        if count != nh:
            #print('Zero count at column {} is: {} != {}'.format(i + 1, count, nh))
            passed = False
    return passed

def pass_rule_2(n, t):
    passed = True
    for i in range(0, n):
        row = t.get_row(i)
        col = t.get_col(i)

        for j in range(0, n - 2):                
            if (row[j] == '0' and row[j + 1] == '0' and row[j + 2] == '0') or (row[j] == '1' and row[j + 1] == '1' and row[j + 2] == '1'):
                #print('Consecutive colors at row {}, index: {}'.format(i + 1, j))
                passed = False

            if (col[j] == '0' and col[j + 1] == '0' and col[j + 2] == '0') or (col[j] == '1' and col[j + 1] == '1' and col[j + 2] == '1'):
                #print('Consecutive colors at column {}, index: {}'.format(i + 1, j))
                passed = False

    return passed

def pass_rule_3(n, t):
    def equals(n, a, b):
        for i in range(0, n):
            if a[i] != b[i]:
                return False
        return True

    passed = True
    for i in range(0, t.size()):
        for j in range(0, t.size()):
            if i != j and equals(n, t.get_row(i), t.get_row(j)):
                #print('Rule3 test failed at rows: {}, {}'.format(i + 1, j + 1))
                passed = False
            if i != j and equals(n, t.get_col(i), t.get_col(j)):
                #print('Rule3 test failed at columns: {}, {}'.format(i + 1, j + 1))
                passed = False
    return passed


def print_usage():
    print('USAGE: asp_helper (--table_to_asp <filename>) | (--table_from_asp <size> <text>) | (--execute_asp <size> <max_solutions> <filename>)')

if len(sys.argv) < 2:
    print_usage()
    exit(-1)

if sys.argv[1] == '--table_to_asp':
    if len(sys.argv) != 3:
        print_usage()
        exit(-1)

    t = Table.from_file(sys.argv[2], Table.from_text)
    print(t.to_asp())
elif sys.argv[1] == '--table_from_asp':
    if len(sys.argv) != 4:
        print_usage()
        exit(-1)

    print(Table.from_asp(int(sys.argv[2]), sys.argv[3]))
elif sys.argv[1] == '--execute_asp':
    if len(sys.argv) != 5:
        print_usage()
        exit(-1)

    max_solutions = int(sys.argv[3])
    size = int(sys.argv[2])
    text = ''
    with open(sys.argv[4]) as file:
        text = file.read()

    solutions, result = Clingo.resolve(text, ['-c size={}'.format(size)], max_solutions)
    if len(solutions) != 0:
        errors = [0, 0, 0]
        for i in solutions:
            t = Table.from_asp(size, i)
            print(t)

            if not pass_rule_1(size, t):
                errors[0] += 1

            if not pass_rule_2(size, t):
                errors[1] += 1

            if not pass_rule_3(size, t):
                errors[2] += 1
            
            print()

    print('Result: {}'.format(result))
    for i, j in enumerate(errors):
        print('Not passed rule {}: {}'.format(i + 1, j))
else:
    print_usage()